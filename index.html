<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Avaliação Cadet / Solo Cadet — LEO (EUA)</title>
  <style>
    :root{
      --bg:#071012;
      --card:#0b1a1c;
      --card2:#0d2023;
      --text:#e7f3f3;
      --muted:#a9c7c7;
      --aqua:#25d6c7;
      --aqua2:#18b7aa;
      --border:rgba(37,214,199,.22);
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --danger:#ff6b6b;
      --ok:#65f0c8;
      --warn:#ffd166;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      background:
        radial-gradient(900px 450px at 15% 10%, rgba(37,214,199,.12), transparent 60%),
        radial-gradient(900px 450px at 85% 10%, rgba(24,183,170,.10), transparent 60%),
        var(--bg);
      background-attachment: fixed;
      color:var(--text);
      font: 14.5px/1.55 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    header{
      padding: 28px 16px 8px;
      max-width: 980px;
      margin: 0 auto;
    }
    h1{
      margin:0 0 8px;
      font-weight: 800;
      letter-spacing:.2px;
      font-size: clamp(20px, 2.6vw, 30px);
    }
    .sub{
      color: var(--muted);
      max-width: 74ch;
      margin: 0 0 16px;
    }
    main{
      max-width: 980px;
      margin: 0 auto;
      padding: 0 16px 40px;
      display: grid;
      gap: 14px;
    }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,.01));
      border: 1px solid var(--border);
      border-radius: 14px;
      box-shadow: var(--shadow);
      overflow: hidden;
    }
    .card .hd{
      padding: 14px 16px;
      background: linear-gradient(90deg, rgba(37,214,199,.10), rgba(37,214,199,.03));
      border-bottom: 1px solid var(--border);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .card .hd strong{font-size: 14px}
    .badge{
      font-size: 12px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      color: var(--muted);
      background: rgba(37,214,199,.06);
      white-space: nowrap;
    }
    .card .bd{padding: 14px 16px}

    .grid{
      display:grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 12px;
    }
    .field{grid-column: span 6}
    .field.small{grid-column: span 3}
    label{
      display:block;
      font-weight: 650;
      margin-bottom: 6px;
      color: var(--text);
    }
    input, select, textarea{
      width:100%;
      border-radius: 12px;
      border: 1px solid rgba(37,214,199,.22);
      background: rgba(7,16,18,.55);
      color: var(--text);
      padding: 10px 12px;
      outline: none;
    }
    .help{
      color: var(--muted);
      font-size: 12.5px;
      margin-top: 6px;
    }

    .q{
      padding: 14px 16px;
      border-top: 1px solid rgba(37,214,199,.10);
      background: linear-gradient(180deg, rgba(11,26,28,.75), rgba(11,26,28,.5));
    }
    .q:first-child{border-top:none}
    .q .qt{
      display:flex;
      gap: 10px;
      align-items:flex-start;
      justify-content:space-between;
      margin-bottom: 10px;
    }
    .q .n{
      min-width: 44px;
      height: 28px;
      border-radius: 999px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      border: 1px solid rgba(37,214,199,.26);
      color: var(--aqua);
      background: rgba(37,214,199,.06);
      font-weight: 800;
      font-size: 12px;
    }
    .q h3{
      margin: -2px 0 0;
      font-size: 15px;
      line-height: 1.35;
      font-weight: 760;
      flex: 1;
    }
    .options{
      display:grid;
      gap: 8px;
      margin-top: 8px;
    }
    .opt{
      border: 1px solid rgba(37,214,199,.16);
      border-radius: 12px;
      padding: 10px 12px;
      display:flex;
      gap: 10px;
      align-items:flex-start;
      background: rgba(13,32,35,.45);
      transition: transform .08s ease, border-color .12s ease, background .12s ease;
    }
    .opt:hover{
      border-color: rgba(37,214,199,.35);
      background: rgba(13,32,35,.65);
      transform: translateY(-1px);
    }
    .opt input{
      width: 18px;
      height: 18px;
      margin-top: 2px;
      accent-color: var(--aqua);
      cursor:pointer;
    }
    .opt span{
      color: var(--text);
    }
    #detailText {
      white-space: pre-line;
    }

    .actions{
      display:flex;
      flex-wrap:wrap;
      gap: 10px;
      align-items:center;
      justify-content:space-between;
      padding: 14px 16px;
      border-top: 1px solid rgba(37,214,199,.12);
      background: rgba(13,32,35,.35);
    }
    button{
      appearance:none;
      border: 1px solid rgba(37,214,199,.35);
      background: linear-gradient(180deg, rgba(37,214,199,.20), rgba(37,214,199,.08));
      color: var(--text);
      padding: 10px 14px;
      border-radius: 12px;
      font-weight: 760;
      cursor:pointer;
      transition: transform .08s ease, border-color .12s ease, background .12s ease;
    }
    button:hover{
      border-color: rgba(37,214,199,.6);
      transform: translateY(-1px);
    }
    button:disabled{
      opacity:.55;
      cursor:not-allowed;
      transform:none;
    }
    .secondary{
      border-color: rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      font-weight: 650;
      color: var(--muted);
    }

    .result{
      display:grid;
      gap: 8px;
      padding: 14px 16px;
    }
    .result .row{
      display:flex;
      flex-wrap:wrap;
      gap: 10px;
      align-items:center;
      justify-content:space-between;
    }
    .score{
      font-size: 18px;
      font-weight: 900;
      letter-spacing: .2px;
    }
    .status{
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(37,214,199,.25);
      background: rgba(37,214,199,.06);
      color: var(--muted);
      font-weight: 750;
      font-size: 12px;
    }
    .status.ok{
      border-color: rgba(101,240,200,.35);
      background: rgba(101,240,200,.07);
      color: var(--ok);
    }
    .status.warn{
      border-color: rgba(255,209,102,.30);
      background: rgba(255,209,102,.07);
      color: var(--warn);
    }
    .status.bad{
      border-color: rgba(255,107,107,.30);
      background: rgba(255,107,107,.08);
      color: var(--danger);
    }
    .smallprint{
      color: var(--muted);
      font-size: 12.5px;
      margin: 0;
    }

    @media (max-width: 860px){
      .field{grid-column: span 12}
      .field.small{grid-column: span 6}
    }
  </style>
</head>

<body>
  <header>
    <h1><div style="background: url('https://r2.fivemanage.com/image/JPNEVXYBJePj.png') no-repeat top center; background-size: contain; width: 100%; height: 150px; box-sizing: content-box; margin-bottom: 1em"></h1>
  </header>

  <main>
    <form id="quizForm" class="card" autocomplete="off">
      <div class="hd">
        <strong>Dados do candidato</strong>
        <span class="badge">Dados informados no RP</span>
      </div>

      <div class="bd">
        <div class="grid">
          <div class="field">
            <label for="charName">Nome do personagem</label>
            <input id="charName" name="charName" placeholder="Ex.: John Edwards" required />
          </div>

          <div class="field">
            <label for="age">Idade</label>
            <input id="age" name="age" type="number" min="16" max="90" placeholder="Ex.: 38" required />
          </div>

          <div class="field">
            <label for="discord">Discord</label>
            <input id="discord" name="discord" placeholder="Ex.: Raphael#1234 ou @raphael" required />
          </div>

          <div class="field">
            <label for="fto">Oficial FTO</label>
            <input id="fto" name="fto" placeholder="Ex.: Sgt. Silva" required />
          </div>

          <!-- <div class="field">
            <label for="webhook">Discord Webhook (opcional)</label>
            <input id="webhook" name="webhook" placeholder="Cole aqui o webhook do canal (opcional)" />
            <div class="help">
              Observação: enviar direto do navegador pode falhar por CORS/segurança. Se isso acontecer, use um proxy/backend.
            </div> -->
          </div>
        </div>
      </div>

      <div class="hd">
        <strong>Perguntas</strong>
        <span class="badge"><span id="countAnswered">0</span>/<span id="countTotal">0</span> respondidas</span>
      </div>

      <div id="questions"></div>

      <div class="actions">
        <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center">
          <button type="button" id="gradeBtn">Calcular nota</button>
          <button type="submit" id="submitBtn">Enviar e mostrar nota</button>
          <button type="button" class="secondary" id="resetBtn">Limpar</button>
        </div>
        <p class="smallprint" id="clientNote">
          A nota é calculada localmente. O envio para o Discord é opcional e não impede ver a nota.
        </p>
      </div>

      <div id="resultCard" class="result" style="display:none">
        <div class="row">
          <div class="score" id="scoreText">Nota: --</div>
          <div class="status" id="statusText">Status: --</div>
        </div>
        <p class="smallprint" id="detailText"></p>
      </div>
    </form>
  </main>

  <script>
    // =========================
    // CONFIG DO QUESTIONÁRIO
    // =========================
    // Regras:
    // - correct: índice da alternativa correta (0..n-1)
    // - critical: se errar, rebaixa (mesmo com nota alta), útil para "força letal / emendas / legalidade"

    // =========================
    // WEBHOOK ESTÁTICO (FIXO)
    // =========================
    const DISCORD_WEBHOOK_URL =
      "https://discord.com/api/webhooks/1470474857190789365/eXmN49FgQfChmga-ZW9T5S4Dq0CTzPjjcLvFfLjhzEOyRZQR5tWhEHquxSh50o7RyycP";

    const QUESTION_BANK = [
      {
        "id": "b1",
        "section": "Estrutura e Jurisdição",
        "text": "Como funciona a autoridade territorial entre LSPD e BCSO?",
        "options": [
          "Cada departamento tem jurisdição exclusiva e a atuação fora depende de autorização",
          "Não há restrição territorial entre departamentos",
          "Somente supervisores podem atuar fora da área administrativa",
          "Atuar fora da área só é permitido em hot pursuit"
        ],
        "correct": 1,
        "critical": true,
        "expected": "UPD é estrutura única; não há limitação territorial interna."
      },
      {
        "id": "b2",
        "section": "Rotina Operacional",
        "text": "Qual é a regra do briefing diário?",
        "options": [
          "Opcional; cada departamento define seu horário",
          "18h00 na MRPD; obrigatório para todos em serviço",
          "19h00 na MRPD; obrigatório apenas para cadets",
          "Somente oficiais da LSPD são obrigados"
        ],
        "correct": 1,
        "critical": false,
        "expected": "Briefing diário às 18h00 na MRPD é obrigatório."
      },
      {
        "id": "b3",
        "section": "Uso da Força",
        "text": "Sobre a escala progressiva de força, qual afirmação é correta?",
        "options": [
          "É uma sequência rígida que não pode ser alterada",
          "São diretrizes; o oficial pode avançar ou reduzir conforme ameaça",
          "Não existe padrão; cada oficial decide livremente sem referência",
          "Sempre começar com o comando verbal"
        ],
        "correct": 1,
        "critical": true,
        "expected": "A escala é diretriz flexível, não sequência rígida."
      },
      {
        "id": "b4",
        "section": "Uso da Força",
        "text": "O que caracteriza o Nível 1 do uso da força?",
        "options": [
          "Ordens claras e objetivas com tom profissional",
          "Controle físico para conter resistência",
          "A simples presença",
          "Uso de ferramentas menos letais (ex.: taser)"
        ],
        "correct": 2,
        "critical": true,
        "expected": "Nível 1 é presença policial sem controle físico ou comando verbal."
      },
      {
        "id": "b5",
        "section": "Uso da Força",
        "text": "O que caracteriza o Nível 2 do uso da força?",
        "options": [
          "Imobilização imediata para garantir controle",
          "Emissão de ordens claras, diretas e objetivas.",
          "Uso de taser para garantir conformidade",
          "Apreensão e revista completa por rotina"
        ],
        "correct": 1,
        "critical": true,
        "expected": "Nível 2 é comando verbal claro, direto e profissional."
      },
      {
        "id": "b6",
        "section": "Uso da Força",
        "text": "Quando o Nível 3 do uso da força é apropriado?",
        "options": [
          "Quando há resistência física dificultando algemação ou luta ativa contra o oficial",
          "Quando há silêncio do suspeito durante perguntas",
          "Sempre que houver qualquer desobediência verbal",
          "Apenas em crimes violentos com arma de fogo"
        ],
        "correct": 0,
        "critical": true,
        "expected": "Controle físico se aplica a resistência física/ativa."
      },
      {
        "id": "b7",
        "section": "Uso da Força (Menos Letal)",
        "text": "O Nível 4 do uso da força pode ser usado quando:",
        "options": [
          "Há resistência ativa/ameaça moderada e níveis anteriores são insuficientes",
          "O suspeito está apenas nervoso",
          "Sempre antes de algemar alguém",
          "Somente após o suspeito atacar fisicamente primeiro"
        ],
        "correct": 0,
        "critical": true,
        "expected": "Menos letal é para resistência ativa/ameaça moderada quando necessário."
      },
      {
        "id": "b8",
        "section": "Uso da Força Letal",
        "text": "Quando é autorizado o uso de força letal?",
        "options": [
          "Quando o suspeito foge após ordem de parada",
          "Quando há ameaça imediata de morte ou lesão corporal grave ao oficial ou terceiros",
          "Quando o suspeito está armado",
          "Quando há desobediência repetida"
        ],
        "correct": 1,
        "critical": true,
        "expected": "Força letal exige ameaça imediata de morte/lesão grave."
      },
      {
        "id": "b9",
        "section": "Gang War",
        "text": "Confirmada guerra entre gangues, qual ação inicial é exigida?",
        "options": [
          "Avançar para dentro da zona de combate para separar os envolvidos",
          "Acionar apoio aéreo e manter perímetro seguro sem avançar enquanto houver disparos ativos",
          "Executar PIT no primeiro veículo em fuga imediatamente",
          "Prender sobreviventes antes de evidenciar a cena"
        ],
        "correct": 1,
        "critical": true,
        "expected": "Aéreo + perímetro; não avançar com disparos ativos."
      },
      {
        "id": "b10",
        "section": "Gang War (Pós-confronto)",
        "text": "Após o fim do confronto entre gangs, qual prioridade máxima?",
        "options": [
          "Iniciar entrevista imediata com sobreviventes",
          "Preservar a cena, impedir coleta de itens dos inconscientes e controlar a área",
          "Reanimar todos imediatamente antes de evidenciar",
          "Liberar todos para reduzir aglomeração"
        ],
        "correct": 1,
        "critical": true,
        "expected": "Preservação e controle de cena são prioridade máxima."
      },
      {
        "id": "b11",
        "section": "Gang War (Perseguição)",
        "text": "Após a cena estar sob controle, qual limite para perseguição a sobreviventes?",
        "options": [
          "Sem limite; todas as viaturas podem perseguir",
          "Máximo de 2 viaturas por veículo",
          "Máximo de 4 viaturas por veículo",
          "Somente 1 viatura pode perseguir"
        ],
        "correct": 2,
        "critical": true,
        "expected": "Limite de 4 viaturas por veículo (aéreo não conta)."
      },
      {
        "id": "b12",
        "section": "Gang War (Intervenção)",
        "text": "Quando a intervenção direta da polícia é permitida em confrontos entre gangues?",
        "options": [
          "Sempre que houver troca de tiros entre gangues",
          "Quando disparos forem efetuados propositalmente contra policiais ou risco imediato a civis em locais de grande circulação",
          "Apenas após autorização do DOJ",
          "Somente após o confronto terminar"
        ],
        "correct": 1,
        "critical": true,
        "expected": "Intervenção quando houver tiros direcionados à polícia e/ou risco imediato a civis."
      },
      {
        "id": "b13",
        "section": "Áreas de Risco",
        "text": "Após uma área ser oficialmente mapeada como área de risco, o que acontece?",
        "options": [
          "Patrulha individual fica proibida",
          "Só SWAT pode entrar, sem exceção",
          "A área fica sob jurisdição exclusiva do BCSO",
          "Chamados do dispatch devem ser ignorados"
        ],
        "correct": 0,
        "critical": false,
        "expected": "Sem patrulha individual; comunicar e atuar com reforço."
      },
      {
        "id": "b14",
        "section": "Áreas de Risco",
        "text": "Se um oficial estiver sozinho e receber chamado/denúncia em área de risco, qual conduta é correta?",
        "options": [
          "Entrar para confirmar visual e abordar imediatamente",
          "Evidenciar de forma segura e elaborar um relatório com a denúncia e observações",
          "Solicitar PIT/BOX/SPIKE para controlar a região",
          "Ignorar o chamado"
        ],
        "correct": 1,
        "critical": false,
        "expected": "Evidenciar de posição segura + relatório; pedir reforço na rádio."
      },
      {
        "id": "b15",
        "section": "Áreas de Risco (Incursão)",
        "text": "Quais requisitos mínimos para uma incursão em área de risco?",
        "options": [
          "Mínimo 4 oficiais e autorização do primário",
          "Mínimo 8 oficiais e autorização de Supervisor+",
          "Qualquer efetivo se houver BOLO",
          "Somente com apoio aéreo, independentemente do efetivo"
        ],
        "correct": 1,
        "critical": false,
        "expected": "8+ oficiais, 1 a mais que suspeitos, Supervisor+ e relatório completo com evidências."
      },
      {
        "id": "b16",
        "section": "Sequestro / Negociação",
        "text": "Em ocorrências de sequestro, qual postura de armamento o manual exige?",
        "options": [
          "On Target, Arma apontada",
          "Low Ready, Pronto para apontar",
          "Arma guardada para evitar escalada",
          "Taser sempre em mãos"
        ],
        "correct": 1,
        "critical": false,
        "expected": "Low Ready é obrigatório."
      },
      {
        "id": "b17",
        "section": "Sequestro / Negociação",
        "text": "Se não houver negociador disponível, quem assume a condução da ocorrência de sequestro?",
        "options": [
          "O cadet mais antigo",
          "O oficial de maior rank presente",
          "O primeiro a chegar",
          "Somente com a presença de um advogado"
        ],
        "correct": 1,
        "critical": false,
        "expected": "Maior rank assume na ausência de negociador."
      },
      {
        "id": "b18",
        "section": "Sequestro / Negociação",
        "text": "Qual concessão o manual admite como possível durante negociação de sequestro?",
        "options": [
          "Pagamento/recompensa",
          "Liberação de presos para troca",
          "Passagem segura até o veículo",
          "Entrega de armamento ao sequestrador"
        ],
        "correct": 2,
        "critical": false,
        "expected": "Só passagem segura até o veículo (quando autorizada)."
      },
      {
        "id": "b19",
        "section": "Yellow Line",
        "text": "Qual afirmação descreve corretamente a Yellow Line?",
        "options": [
          "Permite avanço ofensivo enquanto houver comunicação ativa",
          "Prioriza preservar vida do refém via conversa/desescalada; sem avanço ofensivo com comunicação ativa",
          "É aplicada apenas quando um oficial foi sequestrado",
          "Autoriza força imediata para neutralização"
        ],
        "correct": 1,
        "critical": false,
        "expected": "Yellow Line = negociação viável; sem avanço ofensivo com comunicação ativa."
      },
      {
        "id": "b20",
        "section": "Red Line",
        "text": "A Red Line é autorizada quando ocorre:",
        "options": [
          "Qualquer demora na negociação",
          "Quando houver sequestro de oficial, tentativa de execução do refém, disparos direcionados ou recusa absoluta de negociar",
          "É aplicada apenas quando um oficial foi sequestrado",
          "Apenas quando o suspeito pede dinheiro"
        ],
        "correct": 1,
        "critical": false,
        "expected": "Red Line = quebra total; autoriza neutralização imediata sob critérios do manual."
      },
      {
        "id": "b21",
        "section": "Atividade Suspeita",
        "text": "Ao receber denúncia via dispatch de atividade suspeita, como o oficial deve se aproximar inicialmente?",
        "options": [
          "Com sirene e luminoso para mostrar presença",
          "Sem sirene/luminoso, posicionando-se seguro para evidenciar",
          "Apenas por telefone, sem ir ao local",
          "Somente após supervisor autorizar"
        ],
        "correct": 1,
        "critical": false,
        "expected": "Chegada discreta + evidenciação."
      },
      {
        "id": "b22",
        "section": "Jurisprudência (Terry)",
        "text": "Quando um Terry Frisk é permitido?",
        "options": [
          "Desde que exista suspeita razoável",
          "Apenas com mandado",
          "Somente após prisão",
          "Somente em crimes violentos confirmados"
        ],
        "correct": 0,
        "critical": false,
        "expected": "Suspeita razoável permite stop e frisk (revista externa superficial)."
      },
      {
        "id": "b23",
        "section": "Traffic Stop",
        "text": "Qual local é desencorajado para traffic stop?",
        "options": [
          "Rua bem iluminada e com espaço de acostamento",
          "Após descidas, pontes, interseções, áreas muito povoadas, túneis e áreas de alto risco",
          "Estacionamentos amplos e vazios",
          "Avenidas retas com boa visibilidade"
        ],
        "correct": 1,
        "critical": true,
        "expected": "Evitar locais que bloqueiam tráfego e aumentam risco (pontes, túneis etc.)."
      },
      {
        "id": "b24",
        "section": "Traffic Stop",
        "text": "Qual distância mínima o manual recomenda entre viatura e veículo parado no traffic stop?",
        "options": [
          "Encostar a viatura no veículo para evitar fuga",
          "Pelo menos 1 metro",
          "No mínimo 5 metros",
          "Sem regra; depende do humor do oficial"
        ],
        "correct": 1,
        "critical": true,
        "expected": "Manter pelo menos 1 metro de distância."
      },
      {
        "id": "b25",
        "section": "BOLO / Mimms",
        "text": "BOLO deve ser tratado como:",
        "options": [
          "Causa provável automática",
          "Suspeita razoável",
          "Informação inválida para qualquer ação",
          "Autorização para busca completa do veículo sempre"
        ],
        "correct": 1,
        "critical": false,
        "expected": "BOLO = suspeita razoável; BOLO violento pode justificar felony stop."
      },
      {
        "id": "b26",
        "section": "Felony Stop (Busca)",
        "text": "Em situações de suspeita razoável durante felony stop, qual busca no veículo é permitida?",
        "options": [
          "Busca completa do veículo por padrão",
          "Verificação rápida e limitada para procurar armamentos em áreas de acesso imediato (ex.: porta-luvas)",
          "Busca em todo o porta-malas por itens",
          "Demonstar o carro e mandar todas as peças para averiguação"
        ],
        "correct": 1,
        "critical": true,
        "expected": "Busca limitada por armas em áreas de acesso imediato; não é busca completa."
      },
      {
        "id": "b27",
        "section": "Felony Stop (Michigan v. Long)",
        "text": "Se nenhuma arma for encontrada na varredura limitada do veículo, o que o manual determina sobre outros itens encontrados?",
        "options": [
          "Podem ser apreendidos por rotina",
          "Devem ser ignorados",
          "Devem ser fotografados e anexados sempre",
          "Devem ser revistados integralmente para buscar contrabando"
        ],
        "correct": 1,
        "critical": true,
        "expected": "Sem arma encontrada, outros itens devem ser ignorados na varredura limitada."
      },
      {
        "id": "b28",
        "section": "Comunicação na Rádio",
        "text": "Para comunicações não essenciais, qual prática o manual recomenda?",
        "options": [
          "Usar a frequência principal para qualquer assunto",
          "Usar 311",
          "Evitar comunicação para não poluir o rádio",
          "Acender uma fogueira e mandar sinal de fumaça"
        ],
        "correct": 1,
        "critical": false,
        "expected": "Não essencial: 311/mudança de frequência ou contato telefônico."
      },
      {
        "id": "b29",
        "section": "PBS (PIT/BOX/SPIKE)",
        "text": "Em regra de padronização, quando o PIT é autorizado?",
        "options": [
          "Se a pessoa for muito chata e ficar falando o tempo todo",
          "Após no minimo 15 minutos de perseguição ativa, ou antes em condições especiais",
          "Somente após 30 minutos",
          "Apenas se o suspeito bater em uma viatura"
        ],
        "correct": 1,
        "critical": false,
        "expected": "PIT após 15 min (ou antes nas exceções do manual)."
      },
      {
        "id": "b30",
        "section": "Cadeia de Comando",
        "text": "Quando a quebra da cadeia de comando é admitida?",
        "options": [
          "Sempre que o oficial discordar da ordem",
          "Apenas em situações excepcionais",
          "Somente quando o oficial é de divisão especializada",
          "Quando o oficial quiser, a primeira emenda o protege"
        ],
        "correct": 1,
        "critical": false,
        "expected": "Quebra é exceção em cenários urgentes; e deve ser comunicada ao superior assim que possível."
      },
      {
        "id": "b31",
        "section": "Liberdade de expressão",
        "text": "Se uma pessoa ficar lhe xingando muito o que você pode fazer?",
        "options": [
          "Dar voz de prisão por desacato",
          "Xingar ele em retorno e se ele vacilar dar 2 tiros no pneu dele",
          "Pedir para que o mesmo mantenha a calma e tentar continuar o dialogo de forma racional",
          "Ofender ele, a primeira emenda me protege também"
        ],
        "correct": 2,
        "critical": true,
        "expected": "Agir como um ser humano e não ligar para o que está sendo falado"
      },
      {
        "id": "b32",
        "section": "Bodycam",
        "text": "Quando é necessário ter a bodycam ligada?",
        "options": [
          "Durante todo o tempo em serviço",
          "Quando quiser",
          "Somente durante roubos e ocorrências",
          "Apenas quando o High Command estiver acordado"
        ],
        "correct": 0,
        "critical": true,
        "expected": "Durante todo o tempo em serviço"
      }
    ];

    // Critério: >= 80% + sem errar críticas => Solo Cadet recomendado
    const PASS_PERCENT = 80;

    // =========================
    // CONFIGURAÇÃO DO QUIZ
    // =========================

      const QUIZ_SIZE = 15;

      function shuffleArray(array) {
        const arr = array.slice();
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
      }

      function shuffleOptionsPreserveAnswer(q) {
        const paired = q.options.map((opt, idx) => ({
          text: opt,
          isCorrect: idx === q.correct
        }));

        const shuffled = shuffleArray(paired);
        const newCorrectIndex = shuffled.findIndex(o => o.isCorrect);

        return {
          ...q,
          options: shuffled.map(o => o.text),
          correct: newCorrectIndex
        };
      }

      function pickQuizQuestions(questionBank, n) {
        const shuffledQuestions =
          shuffleArray(questionBank).map(shuffleOptionsPreserveAnswer);

        return shuffledQuestions.slice(0, Math.min(n, shuffledQuestions.length));
      }

      const QUESTIONS = pickQuizQuestions(QUESTION_BANK, QUIZ_SIZE);

    // =========================
    // RENDER
    // =========================
    const questionsEl = document.getElementById("questions");
    const countAnsweredEl = document.getElementById("countAnswered");
    const countTotalEl = document.getElementById("countTotal");
    countTotalEl.textContent = String(QUESTIONS.length);

    function renderQuestions(){
      questionsEl.innerHTML = "";
      QUESTIONS.forEach((q, idx) => {
        const wrap = document.createElement("div");
        wrap.className = "q";
        wrap.dataset.qid = q.id;

        const top = document.createElement("div");
        top.className = "qt";

        const n = document.createElement("div");
        n.className = "n";
        n.textContent = String(idx + 1);

        const title = document.createElement("h3");
        title.textContent = q.text.replace(/^\d+\)\s?/, `${idx+1}) `);

        top.appendChild(n);
        top.appendChild(title);

        const opts = document.createElement("div");
        opts.className = "options";

        q.options.forEach((opt, i) => {
          const label = document.createElement("label");
          label.className = "opt";

          const input = document.createElement("input");
          input.type = "radio";
          input.name = q.id;
          input.value = String(i);
          input.required = true;

          input.addEventListener("change", updateAnsweredCount);

          const span = document.createElement("span");
          span.textContent = opt;

          label.appendChild(input);
          label.appendChild(span);
          opts.appendChild(label);
        });

        wrap.appendChild(top);
        wrap.appendChild(opts);
        questionsEl.appendChild(wrap);
      });

      updateAnsweredCount();
    }

    function updateAnsweredCount(){
      let answered = 0;
      QUESTIONS.forEach(q => {
        const selected = document.querySelector(`input[name="${q.id}"]:checked`);
        if(selected) answered++;
      });
      countAnsweredEl.textContent = String(answered);
    }

    function shuffleArray(array) {
      const arr = array.slice(); // não muta o original diretamente
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    // Embaralha alternativas de cada pergunta sem quebrar o gabarito
    function shuffleQuestionsWithOptions(questions) {
      return shuffleArray(questions).map(q => {
        // cria pares { texto, éCorreta }
        const paired = q.options.map((opt, idx) => ({
          text: opt,
          isCorrect: idx === q.correct
        }));

        // embaralha as alternativas
        const shuffled = shuffleArray(paired);

        // encontra novo índice da correta
        const newCorrectIndex = shuffled.findIndex(o => o.isCorrect);

        return {
          ...q,
          options: shuffled.map(o => o.text),
          correct: newCorrectIndex
        };
      });
    }

    const SHUFFLED_QUESTIONS = shuffleQuestionsWithOptions(QUESTIONS);

    // sobrescreve a base usada pelo sistema
    QUESTIONS.length = 0;
    SHUFFLED_QUESTIONS.forEach(q => QUESTIONS.push(q));

    renderQuestions();

    // =========================
    // SCORING
    // =========================
    function grade(){
      let correct = 0;
      let answered = 0;
      const wrongCritical = [];

      const answers = {};

      QUESTIONS.forEach(q => {
        const selected = document.querySelector(`input[name="${q.id}"]:checked`);
        if(selected){
          answered++;
          const chosen = Number(selected.value);
          answers[q.id] = chosen;

          if(chosen === q.correct){
            correct++;
          } else if(q.critical){
            wrongCritical.push(q);
          }
        }
      });

      const percent = Math.round((correct / QUESTIONS.length) * 100);
      return { correct, total: QUESTIONS.length, percent, answered, wrongCritical, answers };
    }

    function getStatus(score){
      const passByScore = score.percent >= PASS_PERCENT;
      const passByCritical = score.wrongCritical.length === 0;

      if(score.answered < QUESTIONS.length){
        return { label:"Incompleto", cls:"warn", recommended:"Complete todas as perguntas." };
      }

      if(passByScore && passByCritical){
        return { label:"Aprovado — Solo Cadet", cls:"ok", recommended:"Recomendado para Solo Cadet (com monitoramento leve no início)." };
      }

      if(passByScore && !passByCritical){
        return { label:"Aprovado com restrição", cls:"warn", recommended:"Pontuação OK, mas errou itens críticos. Recomendado: Cadet." };
      }

      if(!passByScore && score.percent >= 60){
        return { label:"Em treinamento — Cadet", cls:"warn", recommended:"Recomendado: Cadet supervisionado, revisar fundamentos." };
      }

      return { label:"Reprovado — Reforço básico", cls:"bad", recommended:"Recomendado: Re-treino e nova avaliação." };
    }

    function getCriticalMistakes(score) {
      // score.answers = { [q.id]: chosenIndex }
      // QUESTIONS = perguntas ativas do quiz (já embaralhadas)
      const mistakes = [];

      QUESTIONS.forEach((q, idx) => {
        if (!q.critical) return;

        const chosenIndex = score.answers[q.id];
        if (chosenIndex === undefined) return; // não respondeu (ou bloqueio)

        if (chosenIndex !== q.correct) {
          mistakes.push({
            number: idx + 1,
            question: q.text,
            chosenIndex,
            chosenText: q.options[chosenIndex] ?? "(sem resposta)",
            correctIndex: q.correct,
            correctText: q.options[q.correct] ?? "(indisponível)"
          });
        }
      });

      return mistakes;
    }

    function showResult(score) {
      const status = getStatus(score);
      const resultCard = document.getElementById("resultCard");
      const scoreText = document.getElementById("scoreText");
      const statusText = document.getElementById("statusText");
      const detailText = document.getElementById("detailText");

      scoreText.textContent = `Nota: ${score.percent}% (${score.correct}/${score.total})`;
      statusText.textContent = `Status: ${status.label}`;
      statusText.className = `status ${status.cls}`;

      let details = status.recommended;

      // NOVO: listar erros críticos com escolha feita
      const criticalMistakes = getCriticalMistakes(score);
      if (criticalMistakes.length) {
        details += "\n\nErros em itens críticos (mostrando o que foi marcado):\n";

        criticalMistakes.forEach(m => {
          details += `\n${m.number}) ${m.question}\n`;
          details += `- Você marcou: ${m.chosenText}\n`;
          // Se você NÃO quiser revelar a resposta correta, apague a linha abaixo:
          details += `- Resposta correta: ${m.correctText}\n`;
        });
      }

      detailText.textContent = details;
      resultCard.style.display = "grid";
      resultCard.scrollIntoView({ behavior: "smooth", block: "start" });
    }
    // =========================
    // DISCORD WEBHOOK
    // =========================
    function buildDiscordPayloadWrongOnly(meta, score, { includeCorrect = false } = {}) {
      const status = getStatus(score);

      // Monta lista de questões erradas com o que marcou (e opcionalmente a correta)
      const wrong = [];
      QUESTIONS.forEach((q, idx) => {
        const chosenIndex = score.answers[q.id];
        if (chosenIndex === undefined) return; // não respondeu
        if (chosenIndex !== q.correct) {
          wrong.push({
            number: idx + 1,
            question: q.text,
            chosenText: q.options[chosenIndex] ?? "(inválido)",
            correctText: q.options[q.correct] ?? "(indisponível)",
            critical: !!q.critical
          });
        }
      });

      const lines = [];
      lines.push("**Resultado Avaliação LEO**");
      lines.push(`**Personagem:** *${meta.charName}* | **Idade:** *${meta.age}*`);
      lines.push(`**Discord:** *${meta.discord}* | **FTO:** *${meta.fto}*`);
      lines.push(`**Nota:** *${score.percent}%* (${score.correct}/${score.total})`);
      lines.push(`**Status:** *${status.label}*`);

      if (wrong.length === 0) {
        lines.push("");
        lines.push("Nenhuma pergunta errada.");
        return { content: lines.join("\n") };
      }

      // Ordena para mostrar críticas primeiro (opcional, mas útil)
      wrong.sort((a, b) => Number(b.critical) - Number(a.critical));

      lines.push("");
      lines.push(`**Perguntas erradas** (${wrong.length}):`);
      lines.push("```");

      wrong.forEach(w => {
        lines.push(`${w.number}) ${w.question}`);
        lines.push(`   Marcou: ${w.chosenText}`);
        if (includeCorrect) {
          lines.push(`   Correta: ${w.correctText}`);
        }
        lines.push("");
      });

      lines.push("```");

      // Proteção do limite (Discord content ~ 2000 chars)
      let content = lines.join("\n");
      if (content.length > 1900) {
        content = content.slice(0, 1900) + "\n...(cortado por limite do Discord)";
      }

      return { content };
    }

    async function sendWrongOnlyToDiscordWebhook(webhookUrl, meta, score, opts) {
      const payload = buildDiscordPayloadWrongOnly(meta, score, opts);

      const res = await fetch(webhookUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });

      if (!res.ok) {
        const txt = await res.text().catch(() => "");
        throw new Error(`Webhook falhou: HTTP ${res.status} ${res.statusText} ${txt}`.trim());
      }
    }

    // =========================
    // HANDLERS
    // =========================
    const form = document.getElementById("quizForm");
    const gradeBtn = document.getElementById("gradeBtn");
    const resetBtn = document.getElementById("resetBtn");
    const submitBtn = document.getElementById("submitBtn");

    gradeBtn.addEventListener("click", () => {
      const score = grade();
      showResult(score);
    });

    resetBtn.addEventListener("click", () => {
      form.reset();
      document.getElementById("resultCard").style.display = "none";
      updateAnsweredCount();
      window.scrollTo({top:0, behavior:"smooth"});
    });

form.addEventListener("submit", async (e) => {
  e.preventDefault();

  const meta = {
    charName: document.getElementById("charName").value.trim(),
    age: document.getElementById("age").value.trim(),
    discord: document.getElementById("discord").value.trim(),
    fto: document.getElementById("fto").value.trim()
  };

  const score = grade();
  showResult(score);

  try {
    await sendWrongOnlyToDiscordWebhook(DISCORD_WEBHOOK_URL, meta, score, {
      includeCorrect: false // mantenha false para não vazar gabarito
    });
    document.getElementById("clientNote").textContent =
      "Resultado enviado para o Discord.";
  } catch (err) {
    console.error(err);
    document.getElementById("clientNote").textContent =
      "Falha ao enviar para o Discord (webhook/CORS). A nota no site continua válida.";
  }
});
  </script>
</body>
</html>
